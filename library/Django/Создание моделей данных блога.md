## Создание моделей данных блога

Напомним, что объект Python – это набор данных и методов.

Класс – это концептуальная схема, которая объединяет данные и функциональности в единое целое. Создание нового класса влечет новый тип объекта, позволяя формировать экземпляры этого типа.

Модель Django – это источник информации и поведения данных. Она состоит из класса Python, который является подклассом `django.db.models.Model`.

Каждой модели ставится в соответствие одна таблица базы данных, где каждый атрибут класса соотносится с полем базы данных. Когда вы будете создавать модель, Django будет предоставлять практичный API, чтобы легко запрашивать объекты в базе данных.

Сначала мы определим модели баз данных для приложения `blog`.

Затем сгенерируем для этих моделей миграции базы данных, чтобы создать соответствующие таблицы базы данных.

При применении миграций Django будет создавать таблицу по каждой модели, определенной в файле `models.py` приложения.

## Создание модели поста

Сначала мы определим модель `Post`, которая позволит хранить посты блога в базе данных.

Добавьте следующие ниже строки в файл `models.py` приложения `blog`:

```python
from django.db import models


class Post(models.Model):
    title = models.CharField(max_length=250)
    slug = models.SlugField(max_length=250, unique=True)
    body = models.TextField()

    def __str__(self):
        return self.title
```

Это модель данных для постов блога. Посты будут иметь заголовок, короткую метку под названием slug и тело поста. Давайте взглянем на поля указанной модели:

- **`title`**: поле заголовка поста. Это поле с типом `CharField`, которое транслируется в столбец `VARCHAR` в базе данных SQL;
    
- **`slug`**: поле `SlugField`, которое транслируется в столбец `VARCHAR` в базе данных SQL. Слаг – это короткая метка, содержащая только буквы, цифры, знаки подчеркивания или дефисы. Пост с заголовком `Django Reinhardt: A legend of Jazz` мог бы содержать такой слаг: `django-reinhardt-legend-jazz`. Потом мы будем использовать поле slug для формирования красивых и дружественных для поисковой оптимизации URL-адресов постов блога;
    
- **`body`**: поле для хранения тела поста. Это поле с типом `TextField`, которое транслируется в столбец `Text` в базе данных SQL.
    

В модельный класс также добавлен метод `__str__()`.

Это метод Python, который применяется по умолчанию и возвращает строковый литерал с удобочитаемым представлением объекта.

Django будет использовать этот метод для отображения имени объекта во многих местах, таких как его сайт администрирования.

![](library/Django/_attachments/435846ff122bd97a0fa815fe0fec3370_MD5.png)

Django создаст столбец базы данных для каждого поля модели: `title`, `slug` и `body`. На рисунке хорошо видно, как каждый тип поля соответствует типу данных в базе данных.

Django по умолчанию добавляет поле автоматически увеличивающегося первичного ключа(Primary Key) в каждую модель.

Тип этого поля указывается в конфигурации каждого приложения либо глобально в настроечном параметре `DEFAULT_AUTO_FIELD`.

При создании приложения командой `startapp` значение параметра `DEFAULT_AUTO_FIELD` по умолчанию имеет тип `BigAutoField`. Это 64-битное целое число, которое увеличивается автоматически в соответствии с доступными идентификаторами.

Если не указывать первичный ключ своей модели, то Django будет добавлять это поле автоматически.

В качестве первичного ключа можно также определить одно из полей модели, установив для него параметр `primary_key=True`.

Мы расширим модель `Post` дополнительными полями и поведением. После завершения мы синхронизируем ее с базой данных, создав миграцию в базе данных и применив ее.

## Добавление полей даты/времени

Мы продолжим, добавив в модель `Post` различные поля даты/времени.

Каждый пост будет публиковаться в определенную дату и время. Следовательно, необходимо иметь поле для хранения даты и времени публикации. Мы также хотим хранить дату и время создания объекта `Post` и его последнего изменения.

Отредактируйте файл `models.py` приложения `blog`, придав ему следующий вид:

```python
from django.db import models
from django.utils import timezone


class Post(models.Model):
    title = models.CharField(max_length=250)
    slug = models.SlugField(max_length=250, unique=True)
    body = models.TextField()

    publish = models.DateTimeField(default=timezone.now)  # поле даты публикации
    created = models.DateTimeField(auto_now_add=True)  # поле даты создания
    updated = models.DateTimeField(auto_now=True)  # поле даты изменения

    def __str__(self):
        return self.title
```

В модель `Post` были добавлены следующие ниже поля:

- **`publish`**: поле с типом `DateTimeField`, которое транслируется в столбец `DATETIME` в базе данных SQL. Оно будет использоваться для хранения даты и времени публикации поста. По умолчанию значения поля задаются методом Django `timezone.now`. Обратите внимание, что для того, чтобы использовать этот метод, был импортирован модуль `timezone`. Метод `timezone.now` возвращает текущую дату/время в формате, зависящем от часового пояса. Его можно трактовать как версию стандартного метода Python `datetime.now` с учетом часового пояса;
    
- **`created`**: поле с типом `DateTimeField`. Оно будет использоваться для хранения даты и времени создания поста. При применении параметра `auto_now_add` дата будет сохраняться автоматически во время создания объекта;
    
- **`updated`**: поле с типом `DateTimeField`. Оно будет использоваться для хранения последней даты и времени обновления поста. При применении параметра `auto_now` дата будет обновляться автоматически во время сохранения объекта.